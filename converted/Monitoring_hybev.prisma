model Monitoring {
  @@map("hybev")
  monitoringId String @id(map: "pkhybev") @map("keyhybev") @db.Char(15)
  contractId String @map("keyhyobj") @db.Char(15) 
  monitoringTypeId String @map("keyhybet") @db.Char(15)
  unitId String? @map("keycmuni") @db.Char(15) 
  monitoringBeforeMeasureUnitId String @map("keycmuni2") @db.Char(15) 
  startDate DateTime @map("fdate") @db.DateTime
  stopDate DateTime? @map("tdate") @db.DateTime
  interval Int @map("intervall") @db.TinyInt
  monitoringBeforeMeasure Int @map("notibefore")
  comment String? @map("monittext") @db.VarChar(200)
  timestamp String @map("timestamp") @db.Char(10) // TODO: Resolve timestamp usage once more context is available

  // Updated Relations
  // TODO: Check if MonitoringMunicipality is accurately represented with reference to [municipalityId]
  // municipality MonitoringMunicipality? @relation("hybev_keycmuniTocmuni", fields: [unitId], references: [municipalityId], onDelete: NoAction, onUpdate: NoAction, map: "fkhybevkeycmuni ")
  
  // TODO: Ensure MonitoringMeasureUnit matches the references for [measureUnitId]
  // measureUnit MonitoringMeasureUnit @relation("hybev_keycmuni2Tocmuni", fields: [monitoringBeforeMeasureUnitId], references: [measureUnitId], onUpdate: NoAction, map: "fkhybevkeycmuni2 ")
  
  monitoringType MonitoringType @relation(fields: [monitoringTypeId], references: [monitoringTypeId], onUpdate: NoAction, map: "fkhybevkeyhybet ")
  
  // TODO: Check correctness of Contract reference [contractId] if any issues arise
  contract Contract @relation(fields: [contractId], references: [contractId], onDelete: Cascade, onUpdate: NoAction, map: "fkhybevkeyhyobj")

  @@index([unitId], map: "fkhybevcmuni")
  @@index([monitoringBeforeMeasureUnitId], map: "fkhybevcmuni2")
  @@index([monitoringTypeId], map: "fkhybevhybet")
  @@index([contractId], map: "fkhybevhyobj")
}